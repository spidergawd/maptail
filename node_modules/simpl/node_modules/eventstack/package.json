{
  "name": "eventstack",
  "description": "Middleware for EventEmitters",
  "version": "0.2.0",
  "homepage": "https://github.com/stagas/eventstack",
  "author": {
    "name": "George Stagas",
    "email": "gstagas@gmail.com",
    "url": "http://stagas.com/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/stagas/eventstack.git"
  },
  "main": "index.js",
  "devDependencies": {
    "tap": "*"
  },
  "scripts": {
    "test": "tap test"
  },
  "engines": {
    "node": "~0.6.8"
  },
  "dependencies": {},
  "readme": "# EventStack\n\nMiddleware for EventEmitters\n\n## Installation\n\n`npm install eventstack`\n\n## Description\n\nSometimes I wished I could take an event and apply some logic to it before\nit reaches the listener. So I made this thingy.\n\nIt is still a regular EventEmitter, with an extra `.use()` method where you\nuse to add middleware to your events.\n\nThe API looks like this:\n\n```javascript\nee.use('some event', function (args, next) {\n  // do stuff here\n  // ...\n  \n  // move on\n  next();\n});\n```\n\nThe function is called in the EventEmitter context with 2 arguments,\n`args` and `next`.\n\n`args` is an `Array` with the event arguments, including the event name, you\ncan use to inspect or transform.\n\nYou call `next()` to move to the next middleware, or emit the event when\nit reaches the end of the stack. It is not necessary to call `next()` all the\ntime, depending on your logic, you could use `this.emit(...)` to emit\na different event or even do nothing.\n\n## Usage\n\nStandalone:\n\n```javascript\nvar ee = new EventStack();\n```\n\nInherit (just like a regular EventEmitter):\n\n```javascript\nfunction Cat () {\n  EventStack.call(this);\n}\n\nutil.inherits(Cat, EventStack);\n\nCat.prototype.meow = function () {\n  this.emit('meow');\n}\n```\n\nPatch existing EventEmitter:\n\n```javascript\nvar ee = new EventEmitter();\nEventStack(ee); // patched!\nee.use(...);\n```\n\n## Example\n\n```javascript\nvar EventStack = require('eventstack');\n\nvar ee = new EventStack;\n\n// add a middleware that waits for `bar` messages on `foo`\n// and re-emits `foobar!` to `bar`!\nee.use('foo', function (args, next) {\n  if (args[1] === 'bar') {\n    this.emit('bar', 'foobar!');\n  } else {\n    next();\n  }\n});\n\nee.on('foo', function (s) {\n  console.log('listener foo:', s);\n});\n\nee.on('bar', function (s) {\n  console.log('listener bar:', s);\n});\n\nee.emit('foo', 'not bar :(');\nee.emit('foo', 'bar');\n\n```\n\n## Licence\n\nMIT/X11",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/stagas/eventstack/issues"
  },
  "_id": "eventstack@0.2.0",
  "dist": {
    "shasum": "2ece0b01c03b546d945c449653539e632174bdc6"
  },
  "_from": "eventstack@~0.2.0",
  "_resolved": "https://registry.npmjs.org/eventstack/-/eventstack-0.2.0.tgz"
}
